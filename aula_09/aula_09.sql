-- CRIAÇÃO DA TABELA FUNCIONARIO

CREATE TABLE FUNCIONARIO (
ID SERIAL PRIMARY KEY, NOME VARCHAR(100), SALARIO DECIMAL(10, 2), DTCONTRATACAO DATE
);

-- CRIAÇÃO DA TABELA FUNCIONARIO_AUDITORIA

CREATE TABLE FUNCIONARIO_AUDITORIA (
ID INT, SALARIO_ANTIGO DECIMAL(10, 2), NOVO_SALARIO DECIMAL(10, 2), DATA_DE_MODIFICACAO_DO_SALARIO TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (ID) REFERENCES FUNCIONARIO(ID)
);

-- INSERÇÃO DE DADOS NA TABELA FUNCIONARIO

INSERT INTO FUNCIONARIO (NOME, SALARIO, DTCONTRATACAO)
VALUES ('MARIA', 5000.00, '2021-06-01');

INSERT INTO FUNCIONARIO (NOME, SALARIO, DTCONTRATACAO)
VALUES ('JOÃO', 4500.00, '2021-07-15');

INSERT INTO FUNCIONARIO (NOME, SALARIO, DTCONTRATACAO)
VALUES ('ANA', 4000.00, '2022-01-10');

INSERT INTO FUNCIONARIO (NOME, SALARIO, DTCONTRATACAO)
VALUES ('PEDRO', 5500.00, '2022-03-20');

INSERT INTO FUNCIONARIO (NOME, SALARIO, DTCONTRATACAO)
VALUES ('LUCAS', 4700.00, '2022-05-25');

-- CRIAÇÃO DO TRIGGER PARA AUDITORIA DE ALTERAÇÕES DE SALÁRIO

CREATE OR REPLACE FUNCTION REGISTRAR_AUDITORIA_SALARIO() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO FUNCIONARIO_AUDITORIA (ID, SALARIO_ANTIGO, NOVO_SALARIO)
VALUES (OLD.ID, OLD.SALARIO, NEW.SALARIO);

RETURN NEW;

END;

$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_SALARIO_MODIFICADO
AFTER UPDATE OF SALARIO ON
FUNCIONARIO
FOR EACH ROW
EXECUTE FUNCTION REGISTRAR_AUDITORIA_SALARIO();

-- ATUALIZA O SALÁRIO DA ANA

UPDATE FUNCIONARIO
SET
SALARIO = 4300.00
WHERE NOME = 'ANA';

-- CONSULTA À TABELA FUNCIONARIO_AUDITORIA PARA VERIFICAR AS MUDANÇAS

SELECT *
FROM FUNCIONARIO_AUDITORIA
WHERE ID = (SELECT ID
FROM FUNCIONARIO
WHERE NOME = 'ANA');


/*#######################################################################################################
####									EXEMPLO COM DESAFIO DE ESTOQUE                               ####
#######################################################################################################*/

-- CRIAÇÃO DA TABELA PRODUTO

CREATE TABLE PRODUTO (
    COD_PROD INT PRIMARY KEY, DESCRICAO VARCHAR(50) UNIQUE, QTDE_DISPONIVEL INT NOT NULL DEFAULT 0
);

-- INSERÇÃO DE PRODUTOS

INSERT INTO PRODUTO
VALUES (1, 'BASICA', 10);

INSERT INTO PRODUTO
VALUES (2, 'DADOS', 5);

INSERT INTO PRODUTO
VALUES (3, 'VERAO', 15);

-- CRIAÇÃO DA TABELA REGISTROVENDAS

CREATE TABLE REGISTROVENDAS (
    COD_VENDA SERIAL PRIMARY KEY, COD_PROD INT, QTDE_VENDIDA INT, FOREIGN KEY (COD_PROD) REFERENCES PRODUTO(COD_PROD) ON
DELETE CASCADE
);

-- CRIAÇÃO DE UM TRIGGER

CREATE OR REPLACE FUNCTION VERIFICA_ESTOQUE() RETURNS TRIGGER AS $$
DECLARE
    QTED_ATUAL INTEGER;

BEGIN
    SELECT QTDE_DISPONIVEL INTO QTED_ATUAL
FROM PRODUTO
WHERE COD_PROD = NEW.COD_PROD;

IF QTED_ATUAL < NEW.QTDE_VENDIDA THEN
        RAISE EXCEPTION 'QUANTIDADE INDISPONIVEL EM ESTOQUE'
ELSE
        UPDATE PRODUTO
SET
QTDE_DISPONIVEL = QTDE_DISPONIVEL - NEW.QTDE_VENDIDA
WHERE COD_PROD = NEW.COD_PROD;

END IF;

RETURN NEW;

END;

$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_VERIFICA_ESTOQUE 
BEFORE INSERT ON
REGISTROVENDAS
FOR EACH ROW 
EXECUTE FUNCTION VERIFICA_ESTOQUE();


-- TENTATIVA DE VENDA DE 5 UNIDADES DE BASICO (DEVE SER BEM-SUCEDIDA, POIS HÁ 10 UNIDADES DISPONÍVEIS)

INSERT INTO REGISTROVENDAS (COD_PROD, QTDE_VENDIDA)
VALUES (1, 5);

-- TENTATIVA DE VENDA DE 6 UNIDADES DE DADOS (DEVE SER BEM-SUCEDIDA, POIS HÁ 5 UNIDADES DISPONÍVEIS E A QUANTIDADE VENDIDA NÃO EXCEDE O ESTOQUE)

INSERT INTO REGISTROVENDAS (COD_PROD, QTDE_VENDIDA)
VALUES (2, 5);

-- TENTATIVA DE VENDA DE 16 UNIDADES DE VERSAO (DEVE FALHAR, POIS SÓ HÁ 15 UNIDADES DISPONÍVEIS)

INSERT INTO REGISTROVENDAS (COD_PROD, QTDE_VENDIDA)
VALUES (3, 16);

